'use strict';

var assert = require('chai').assert;
var sha3 = require('ethjs-sha3');
var generate = require('../index.js').generate;
var getAddress = require('../index.js').getAddress;
var getChecksumAddress = require('../index.js').getChecksumAddress;
var privateToAccount = require('../index.js').privateToAccount;
var privateToPublic = require('../index.js').privateToPublic;
var publicToAddress = require('../index.js').publicToAddress;
var crypto = require('crypto');
var ethUtil = require('ethereumjs-util');
var SandboxedModule = require('sandboxed-module');

SandboxedModule.registerBuiltInSourceTransformer('istanbul');
var invalidGetAddress = SandboxedModule.require('../index.js', {
  requires: {
    './getChecksumAddress.js': function getChecksumAddressJs(addr) {
      return addr + 1;
    }
  },
  singleOnly: true
}).getAddress;

describe('ethjs-account', function () {
  describe('privateToAccount', function () {
    it('should construct properly', function () {
      assert.equal(typeof privateToAccount, 'function');
    });

    it('should be the same as ethereumjs-util', function () {
      var privateKey = '0xccb36826fbd5192c10bba496af42906a7e3b91f87a0ae803e79113fa88c5432c';
      var accountTest = privateToAccount(privateKey);
      var publicKey = new Buffer(accountTest.publicKey.slice(2), 'hex');
      var address = accountTest.address.toLowerCase();

      assert.deepEqual(publicKey, privateToPublic(privateKey));
      assert.equal(address.toLowerCase(), '0x' + ethUtil.privateToAddress(new Buffer(privateKey.slice(2), 'hex')).toString('hex'));
      assert.deepEqual(publicKey, ethUtil.privateToPublic(new Buffer(privateKey.slice(2), 'hex')));
      assert.equal(publicToAddress(publicKey).toLowerCase(), '0x' + ethUtil.publicToAddress(accountTest.publicKey, true).toString('hex'));
    });

    it('should throw under invalid conditions', function () {
      assert.throws(function () {
        return privateToAccount('');
      }, Error);
      assert.throws(function () {
        return privateToAccount('0x');
      }, Error);
      assert.throws(function () {
        return privateToAccount({});
      }, Error);
      assert.throws(function () {
        return privateToAccount(null);
      }, Error);
      assert.throws(function () {
        return privateToAccount('');
      }, Error);
    });

    it('should prodice the same keys given a prefixed and non prefixed private key', function () {
      var privateKey = '0xccb36826fbd5192c10bba496af42906a7e3b91f87a0ae803e79113fa88c5432c';
      var privateKey2 = 'ccb36826fbd5192c10bba496af42906a7e3b91f87a0ae803e79113fa88c5432c';
      assert.deepEqual(privateToPublic(privateKey2), privateToPublic(privateKey));
      assert.deepEqual(privateToAccount(privateKey2), privateToAccount(privateKey));
    });

    it('should function normally', function () {
      var testAccount = privateToAccount(sha3('sfddskj'));

      assert.equal(typeof testAccount, 'object');
      assert.equal(typeof testAccount.privateKey, 'string');
      assert.equal(typeof testAccount.publicKey, 'string');
      assert.equal(typeof testAccount.address, 'string');
      assert.equal(Object.keys(testAccount).length, 3);
      assert.equal(testAccount.privateKey.length, 66);
      assert.equal(testAccount.publicKey.length, 130);
      assert.equal(testAccount.address.length, 42);
    });
  });

  describe('privateToPublic', function () {
    it('should construct properly', function () {
      assert.equal(typeof privateToPublic, 'function');
      assert.equal(typeof privateToPublic(sha3('jksfksf')), 'object');
    });

    it('should throw under invalid conditions', function () {
      assert.throws(function () {
        return privateToPublic('');
      }, Error);
      assert.throws(function () {
        return privateToPublic('0x');
      }, Error);
      assert.throws(function () {
        return privateToPublic({});
      }, Error);
      assert.throws(function () {
        return privateToPublic(null);
      }, Error);
      assert.throws(function () {
        return privateToPublic(42323424342);
      }, Error);
      assert.throws(function () {
        return privateToPublic('');
      }, Error);
    });
  });

  describe('publicToAddress', function () {
    it('should construct properly', function () {
      assert.equal(typeof publicToAddress, 'function');
      assert.equal(typeof publicToAddress(privateToPublic(sha3('jksfksf'))), 'string');
    });

    it('should be the same as ethereumjs-util', function () {
      var accountTest = privateToAccount(sha3('kjsdfkjfkjsf'));
      var publicKey = new Buffer(accountTest.publicKey.slice(2), 'hex');

      assert.equal(publicToAddress(publicKey).toLowerCase(), '0x' + ethUtil.publicToAddress(accountTest.publicKey, true).toString('hex'));
    });

    it('should throw under invalid conditions', function () {
      assert.throws(function () {
        return publicToAddress('');
      }, Error);
      assert.throws(function () {
        return publicToAddress('0x');
      }, Error);
      assert.throws(function () {
        return publicToAddress({});
      }, Error);
      assert.throws(function () {
        return publicToAddress(null);
      }, Error);
      assert.throws(function () {
        return publicToAddress(42323424342);
      }, Error);
      assert.throws(function () {
        return publicToAddress('');
      }, Error);
    });
  });

  describe('generate', function () {
    it('should construct properly', function () {
      assert.equal(typeof generate, 'function');
    });

    it('should throw under invalid conditions', function () {
      assert.throws(function () {
        return generate({});
      }, Error);
      assert.throws(function () {
        return generate(3443432243);
      }, Error);
      assert.throws(function () {
        return generate(undefined);
      }, Error);
      assert.throws(function () {
        return generate(null);
      }, Error);
      assert.throws(function () {
        return generate('');
      }, Error);
    });

    it('should generate an address', function () {
      var testAccount = generate('fdsjklfsdjklsfdjkfsdkjlsfdkjsdfkljskljsdfkjfsdkjlsfkjsfdkjsfdkljsfdkljsdfkjlsdfkjsf');

      assert.equal(typeof testAccount, 'object');
      assert.equal(typeof testAccount.privateKey, 'string');
      assert.equal(typeof testAccount.publicKey, 'string');
      assert.equal(typeof testAccount.address, 'string');
      assert.equal(Object.keys(testAccount).length, 3);
      assert.equal(testAccount.privateKey.length, 66);
      assert.equal(testAccount.publicKey.length, 130);
      assert.equal(testAccount.address.length, 42);
    });

    it('should generate many random addresses', function () {
      for (var i = 0; i < 500; i++) {
        // eslint-disable-line
        var testAccount = generate('fdsjklfsdjklsfdjkfsdkjlsfdkjsdfkljskljsdfkjfsdkjlsfkjsfdkjsfdkljsfdkljsdfkjlsdfkjsf');

        assert.equal(typeof testAccount, 'object');
        assert.equal(typeof testAccount.privateKey, 'string');
        assert.equal(typeof testAccount.publicKey, 'string');
        assert.equal(typeof testAccount.address, 'string');
        assert.equal(Object.keys(testAccount).length, 3);
        assert.equal(testAccount.privateKey.length, 66);
        assert.equal(testAccount.publicKey.length, 130);
        assert.equal(testAccount.address.length, 42);
      }
    });
  });

  describe('getAddress', function () {
    it('should construct properly', function () {
      assert.equal(typeof getAddress, 'function');
    });
  });

  describe('getChecksumAddress', function () {
    it('should construct properly', function () {
      assert.equal(typeof getChecksumAddress, 'function');
    });
  });

  function randomBuffer(length) {
    var buffer = crypto.randomBytes(length);
    return buffer;
  }

  function randomHexString(length) {
    return '0x' + randomBuffer(length).toString('hex');
  }

  describe('test checkSum address, and getAddress', function () {
    it('ethers getAddress should equal official toChecksumAddress', function () {
      function testAddress(address) {
        var official = ethUtil.toChecksumAddress(address);
        var ethers = getAddress(address);
        assert.equal(ethers, official, 'wrong address');
      }

      testAddress('0x0000000000000000000000000000000000000000');
      testAddress('0xffffffffffffffffffffffffffffffffffffffff');
      for (var i = 0; i < 10000; i++) {
        // eslint-disable-line
        testAddress(randomHexString(20));
      }
    });

    it('should throw as invalid get checksum address (checksum error)', function () {
      assert['throw'](function () {
        invalidGetAddress('0xaB41D5688Facc5EB21aD86098BA230D23Cde0E31');
      }, Error);
    });

    it('should throw as invalid checksum', function () {
      assert['throw'](function () {
        getAddress('sdfjhs992');
      }, Error);
    });

    it('should throw as invalid checksum number', function () {
      assert.throws(function () {
        getAddress(234234234);
      }, Error);
    });

    it('should throw as invalid checksum number', function () {
      assert.throws(function () {
        getChecksumAddress(234234234);
      }, Error);
    });

    it('should throw as invalid checksum number', function () {
      assert.throws(function () {
        getChecksumAddress('sdfk^jsfdkjs9');
      }, Error);
    });

    it('should convert non hexed address', function () {
      assert.equal(getAddress('0000000000000000000000000000000000000000'), '0x0000000000000000000000000000000000000000');
    });

    it('test ICAP', function () {
      assert.equal(getAddress('00c5496aee77c1ba1f0854206a26dda82a81d6d8').toLowerCase(), '0x00c5496aee77c1ba1f0854206a26dda82a81d6d8');
    });

    it('test not supported IBAN/ICAP', function () {
      assert.throws(function () {
        return getAddress('XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS');
      }, Error);
    });
  });
});